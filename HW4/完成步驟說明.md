# HW4 完成步驟說明
---
以下是我請claude code幫助我寫功課的過程
並且請他先幫我示範一次，後面我再跟著他留給我的空格慢慢加東西上去
---
## 已完成的部分

### lexer.mll
✅ 空白和註解處理
✅ 部分關鍵字：if, else, def, repeat, forward
✅ 部分顏色：black, white
✅ 運算符號：+, -, *, /, (, ), {, }, ,
✅ 整數和識別字的識別
✅ EOF token

### parser.mly
✅ Token 宣告（部分）
✅ 運算符號優先順序設定

---

## 你需要完成的部分

### 步驟 1：完成 lexer.mll 的保留字

在 [lexer.mll](mini-turtle/lexer.mll) 的第 28 行，補完這些關鍵字：

```ocaml
| "penup"      { PENUP }
| "pendown"    { PENDOWN }
| "turnleft"   { TURNLEFT }
| "turnright"  { TURNRIGHT }
| "color"      { COLOR }
```

在第 33 行，補完其他顏色：

```ocaml
| "red"        { RED }
| "green"      { GREEN }
| "blue"       { BLUE }
```

### 步驟 2：完成 parser.mly 的 Token 宣告

在 [parser.mly](mini-turtle/parser.mly) 的第 15 行，補完：

```ocaml
%token PENUP PENDOWN TURNLEFT TURNRIGHT COLOR
```

在第 19 行，補完：

```ocaml
%token RED GREEN BLUE
```

### 步驟 3：測試問題 1（註解）

創建 `test.logo` 檔案，內容：

```
// 這是註解
(* 這也是註解 *)
```

執行 `make`，應該會看到空白視窗。

---

### 步驟 4：完成算術表達式規則（問題 2）

在 parser.mly 的語法規則區段（`prog:` 之後），新增表達式規則：

```ocaml
/* 表達式 */
expr:
  | INT                           { Econst $1 }
  | IDENT                         { Evar $1 }
  | LPAR expr RPAR                { $2 }
  | expr PLUS expr                { Ebinop (Add, $1, $3) }
  | expr MINUS expr               { Ebinop (Sub, $1, $3) }
  | expr TIMES expr               { Ebinop (Mul, $1, $3) }
  | expr DIV expr                 { Ebinop (Div, $1, $3) }
  | MINUS expr %prec UMINUS       { Ebinop (Sub, Econst 0, $2) }
;
```

**說明**：
- `$1`, `$2`, `$3` 代表規則中第 1、2、3 個符號的值
- `%prec UMINUS` 指定一元負號的優先順序
- 參考 [ast.ml](mini-turtle/ast.ml) 中的型別定義

### 步驟 5：新增 stmt（陳述式）規則

```ocaml
/* 陳述式 */
stmt:
  | FORWARD expr                  { Sforward $2 }
  /* TODO: 補完其他陳述式 */
;
```

你需要補完：
- `PENUP` → `Spenup`
- `PENDOWN` → `Spendown`
- `TURNLEFT expr` → `Sturn $2`（注意：只有左轉在 AST 中）
- `TURNRIGHT expr` → `Sturn (Ebinop (Sub, Econst 0, $2))`（右轉 = 左轉負角度）
- `COLOR color` → `Scolor $2`

### 步驟 6：新增顏色規則

```ocaml
/* 顏色 */
color:
  | BLACK   { Turtle.black }
  | WHITE   { Turtle.white }
  | RED     { Turtle.red }
  | GREEN   { Turtle.green }
  | BLUE    { Turtle.blue }
;
```

### 步驟 7：修改 prog 規則

```ocaml
prog:
  | stmt_list EOF   { { defs = []; main = Sblock $1 } }
;

/* 陳述式列表 */
stmt_list:
  | /* empty */           { [] }
  | stmt stmt_list        { $1 :: $2 }
;
```

### 步驟 8：測試問題 2

創建 `test.logo`：

```
forward 100
```

執行 `make`，應該看到一條水平線。

測試優先順序：

```
forward 100 + 1 * 0
```

應該還是一條線（不是點）。

---

## 後續步驟（問題 3-5）

### 問題 3：其他原子陳述式
補完 penup, pendown, turnleft, turnright, color 的規則。

### 問題 4：區塊和控制結構

```ocaml
stmt:
  | /* ... 之前的規則 ... */
  | IF expr stmt                  { Sif ($2, $3, Sblock []) }
  | IF expr stmt ELSE stmt        { Sif ($2, $3, $5) }
  | REPEAT expr stmt              { Srepeat ($2, $3) }
  | LBRACE stmt_list RBRACE       { Sblock $2 }
;
```

**注意**：if/else 會有 shift/reduce conflict（dangling else 問題），Menhir 預設會選擇 shift，這是正確的行為。

### 問題 5：函數定義和呼叫

```ocaml
prog:
  | def_list stmt_list EOF   { { defs = $1; main = Sblock $2 } }
;

def_list:
  | /* empty */           { [] }
  | def def_list          { $1 :: $2 }
;

def:
  | DEF IDENT LPAR formal_list RPAR stmt
      { { name = $2; formals = $4; body = $6 } }
;

formal_list:
  | /* empty */                   { [] }
  | IDENT                         { [$1] }
  | IDENT COMMA formal_list       { $1 :: $3 }
;

stmt:
  | /* ... 之前的規則 ... */
  | IDENT LPAR expr_list RPAR     { Scall ($1, $3) }
;

expr_list:
  | /* empty */                   { [] }
  | expr                          { [$1] }
  | expr COMMA expr_list          { $1 :: $3 }
;
```

---

## 編譯和測試指令

```bash
cd mini-turtle
make              # 編譯並執行 test.logo
make explain      # 顯示衝突報告
make tests        # 執行所有測試檔案
```

---

## 提示

1. **Token 的順序**：在 lexer.mll 中，關鍵字必須放在 IDENT 之前，否則關鍵字會被識別為識別字。

2. **優先順序**：`%left` 表示左結合，`%right` 表示右結合，從上到下優先順序遞增。

3. **AST 對照**：
   - `Econst` ← 整數
   - `Evar` ← 識別字
   - `Ebinop` ← 二元運算
   - `Sforward` ← forward
   - `Sturn` ← turnleft（正數）或 turnright（負數）
   - `Sblock` ← 區塊 `{ ... }`

4. **調試**：如果遇到錯誤，使用 `make explain` 查看 Menhir 產生的衝突報告。