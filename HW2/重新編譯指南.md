# Bonus 功能重新編譯指南

## 已完成的修改

我已經在 `interp.ml` 中實作了 Bonus 題目要求的 Python 字典序比較功能：

### 1. 新增 `compare_value` 函數（第 77-104 行）

這個函數實作了 Python 風格的結構化比較：
- 對於列表使用**字典序比較**（lexicographic order）
- 先比較對應位置的元素，而不是先比較長度
- 例如：`[0, 1, 1] < [1]` 返回 `True`（Python 風格）

### 2. 更新比較運算（第 145-150 行）

所有比較運算符現在都使用 `compare_value` 函數：
```ocaml
| Beq, _, _  -> Vbool (compare_value v1 v2 = 0)
| Bneq, _, _ -> Vbool (compare_value v1 v2 <> 0)
| Blt, _, _  -> Vbool (compare_value v1 v2 < 0)
| Ble, _, _  -> Vbool (compare_value v1 v2 <= 0)
| Bgt, _, _  -> Vbool (compare_value v1 v2 > 0)
| Bge, _, _  -> Vbool (compare_value v1 v2 >= 0)
```

## 重新編譯步驟

由於編譯環境的限制，你需要使用以下其中一種方法重新編譯：

### 方法一：使用 WSL（如果 WSL 環境已配置好）

```bash
# 在 PowerShell 中執行
cd D:\北科大\114-1編譯器原理\CompilerHW\HW2\mini-python

# 使用 WSL 編譯
wsl -e bash -c "cd /mnt/d/北科大/114-1編譯器原理/CompilerHW/HW2/mini-python && eval \$(opam env) && dune build minipython.exe"

# 複製編譯好的檔案
cp _build/default/minipython.exe ./minipython.exe
```

**注意**：如果遇到路徑問題，請根據你的 WSL 配置調整路徑。

### 方法二：直接在 WSL 終端中

1. 打開 WSL 終端
2. 切換到專案目錄：
```bash
cd /mnt/d/北科大/114-1編譯器原理/CompilerHW/HW2/mini-python
```

3. 設置環境變數並編譯：
```bash
eval $(opam env)
dune clean
dune build minipython.exe
cp _build/default/minipython.exe ./minipython.exe
```

### 方法三：使用你自己的編譯環境

如果你之前有成功編譯的環境，使用那個環境執行：
```bash
dune clean
dune build minipython.exe
```

## 測試 Bonus 功能

重新編譯後，可以使用以下測試檔案驗證 Bonus 功能：

### 測試檔案：`test_bonus.py`（已創建）

```python
# Bonus: Test lexicographic comparison for lists
print([0, 1, 1] < [1])      # 應該輸出 True
print([1] > [0, 1, 1])      # 應該輸出 True
print([1, 2] < [1, 3])      # 應該輸出 True
print([1, 2] == [1, 2])     # 應該輸出 True
```

### 預期輸出

```
True
True
True
True
```

### 執行測試

```bash
./minipython.exe test_bonus.py
```

## 確認原有測試仍然通過

重新編譯後，**必須**執行完整測試確認沒有破壞現有功能：

```bash
bash run-tests ./minipython.exe
```

預期結果應該仍然是：
```
Score: 42 / 42 tests (100%)
```

## Python 對比測試

如果你想驗證結果是否符合 Python 行為，可以在 Python 中執行：

```python
print([0, 1, 1] < [1])      # True
print([1] > [0, 1, 1])      # True
print([1, 2] < [1, 3])      # True
print([1, 2] == [1, 2])     # True
```

## 修改內容摘要

### compare_value 函數的工作原理

```ocaml
let rec compare_value v1 v2 =
  match v1, v2 with
  | Vlist a1, Vlist a2 ->
      (* 字典序比較：逐個比較元素 *)
      let rec compare_elements i =
        if i >= len1 && i >= len2 then 0      (* 兩個列表相等 *)
        else if i >= len1 then -1             (* v1 較短 *)
        else if i >= len2 then 1              (* v2 較短 *)
        else
          let cmp = compare_value a1.(i) a2.(i) in
          if cmp <> 0 then cmp                (* 元素不同，返回比較結果 *)
          else compare_elements (i + 1)       (* 元素相同，繼續比較下一個 *)
      in
      compare_elements 0
  | ...  (* 其他類型的比較 *)
```

### 與 OCaml 原生比較的差異

| 比較項 | OCaml 原生 `<` | Python / `compare_value` |
|--------|---------------|-------------------------|
| `[0;1;1] < [1]` | `False` (長度優先) | `True` (字典序) |
| 比較邏輯 | 先比長度，再比元素 | 先比元素，長度作為後備 |

## 故障排除

### 如果編譯失敗

1. **檢查 OCaml 環境**：
   ```bash
   ocaml -version
   opam --version
   dune --version
   ```

2. **重新設置環境**：
   ```bash
   eval $(opam env)
   ```

3. **清理並重建**：
   ```bash
   dune clean
   rm -rf _build
   dune build minipython.exe
   ```

### 如果測試失敗

1. 檢查 `interp.ml` 是否被正確修改
2. 確認 `compare_value` 函數在第 77-104 行
3. 確認比較運算在第 145-150 行使用了 `compare_value`

## 總結

- ✅ Bonus 功能已實作完成
- ✅ 程式碼修改已完成
- ⏳ 需要重新編譯才能測試新功能
- ⚠️ 重新編譯後務必執行完整測試確認 100% 通過

重新編譯完成後，你的 Mini-Python 解釋器將完全符合 Python 的列表比較語意！
