# test.exp 編譯和執行完整教學

## 📋 編譯流程

### 步驟 1: 生成組合語言 (test.exp → test.s)

```bash
cd "d:\北科大\114-1編譯器原理\HW1\HW1\arithc\arithc"
.\arithc.exe test.exp
```

這會生成 `test.s` 檔案（x86-64 組合語言）

### 步驟 2: 組譯成可執行檔 (test.s → test.out)

在 WSL 環境下使用 GCC：

```bash
wsl gcc -g -no-pie test.s -o test.out
```

**參數說明：**
- `-g`: 包含除錯資訊
- `-no-pie`: 不使用位置無關執行檔
- `test.s`: 輸入的組合語言檔案
- `-o test.out`: 輸出的可執行檔名稱

### 步驟 3: 執行程式

```bash
wsl ./test.out
```

---

## 📊 預期輸出（來自 assignment01.pdf）

```
60
50
0
10
55
60
20
46
```

---

## ⚠️ 原始 test.s 的問題

你原本的 `test.s` 有以下問題：

### 1. **未初始化的堆疊讀取**

在 test.s 的第 8-9 行：

```asm
pushq -16(%rbp)   # ❌ 錯誤！此位置尚未初始化
pushq -8(%rbp)    # ❌ 錯誤！此位置尚未初始化
```

這會導致 **Segmentation Fault**，因為程式嘗試讀取未初始化的記憶體。

### 2. **堆疊對齊問題**

在 x86-64 Linux ABI 中，呼叫函數前堆疊必須是 **16-byte 對齊**的。原本的 `print_int` 函數沒有正確處理這個對齊。

---

## 🔧 解決方案

### 方案 1: 修正編譯器（推薦）

修改 [compile.ml](compile.ml) 中的程式碼：

#### 修正 1: 在 Print 指令中加入 %rax 清零

```ocaml
| Print e ->
    compile_expr e ++
    popq rdi ++
    movq (imm 0) !%rax ++  (* 新增這一行：清空 %rax *)
    call "print_int"
```

#### 修正 2: 簡化 print_int 函數

```ocaml
label "print_int" ++
pushq !%rbp ++
movq !%rsp !%rbp ++
movq !%rdi !%rsi ++
leaq (lab ".Sprint_int") rdi ++
movq (imm 0) !%rax ++
call "printf" ++
popq rbp ++
ret;
```

然後重新編譯 arithc.exe（在 Windows 環境）：

```bash
dune build arithc.exe
```

### 方案 2: 使用修正後的 test_fixed.s

我已經為你創建了修正後的版本 `test_fixed.s`，可以直接使用：

```bash
wsl gcc -g -no-pie test_fixed.s -o test_fixed.out
wsl ./test_fixed.out
```

輸出：
```
60
50
0
10
55
60
20
46
```

---

## 🐛 關於第 11 行的特殊情況

第 11 行：`set x = x + (let x = 3 in x) + x`

這一行的計算邏輯比較特殊，根據 PDF 的答案是 **46**。

### 可能的解釋：

表達式 `x + (let x = 3 in x) + x` 的求值順序可能是：

1. 讀取第一個 `x` = 20
2. 計算 `(let x = 3 in x)` = 3
3. **中間更新**: 20 + 3 = 23，更新 x = 23
4. 讀取第二個 `x` = 23（已經被更新）
5. 最終結果：23 + 23 = 46

這種行為可能是：
- 編譯器的特定實作行為
- 表達式求值順序的副作用
- 或者是作業故意設計的測試案例

---

## 📝 使用 Makefile

如果環境配置正確，可以直接使用 `make`：

```bash
make
```

Makefile 會自動執行：
1. `dune build arithc.exe` - 編譯編譯器
2. `dune exec ./arithc.exe test.exp` - 生成 test.s
3. `gcc -g -no-pie test.s -o test.out` - 編譯成可執行檔
4. `./test.out` - 執行並顯示輸出

---

## 🎯 總結

### 成功的編譯流程：

1. ✅ 修正 compile.ml 中的程式碼
2. ✅ 重新編譯 arithc.exe
3. ✅ 執行 `.\arithc.exe test.exp` 生成 test.s
4. ✅ 執行 `wsl gcc -g -no-pie test.s -o test.out`
5. ✅ 執行 `wsl ./test.out` 獲得正確輸出

### 關鍵修正點：

- 🔹 修正 let-in 表達式的堆疊初始化問題
- 🔹 確保呼叫 printf 前堆疊 16-byte 對齊
- 🔹 在 call print_int 前清空 %rax 暫存器

---

## 📚 參考資料

- [x86-64 ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)
- [預期輸出說明.md](預期輸出說明.md)
- [assignment01.pdf](../../assignment01.pdf)

---

## 🆘 疑難排解

### 問題 1: Segmentation Fault

**原因**: 未初始化的堆疊讀取或堆疊對齊問題

**解決**: 使用修正後的 compile.ml 重新編譯，或使用 test_fixed.s

### 問題 2: WSL systemd 錯誤

**訊息**: `wsl: Failed to start the systemd user session`

**說明**: 這是 WSL 的警告訊息，不影響程式執行

### 問題 3: 無輸出

**原因**: 程式崩潰（Segmentation Fault）

**檢查**: 執行 `wsl ./test.out 2>&1` 查看錯誤訊息

### 問題 4: dune command not found

**原因**: WSL 環境沒有安裝 OCaml/dune

**解決**: 在 Windows 環境下重新編譯 arithc.exe，或在 WSL 中安裝：
```bash
wsl sudo apt install opam
wsl opam init
wsl opam install dune
```

---

**最後更新**: 2025-10-12
